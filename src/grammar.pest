//
// Since newlines are sometimes meaningful syntax, we need to specify what 
// whitespace is permitted where. 
//
// This might be easier in future versions of `pest`, though the addition of 
// this feature has not moved much since the middle of 2022:
// https://github.com/pest-parser/pest/issues/271
//

// whitespace helpers

    WS_NO_NL = _{ " " | "\\t" }
    WS = _{ WS_NO_NL | NEWLINE }
    CAPTURE_WS = { WS+ }
    eoi  = _{ !ANY }  // since EOI does not parse silently, define our own

// highlighting
//
// Syntax highlighting uses a parallel grammar (trying to reuse as much as 
// possible), that tries to be minimally recursive. In the future this might 
// shift to using something like a treesitter grammar, but for now this is 
// just a minimal product for building the infrastructure for highlighting
// into the repl
//

    hl = _{ CAPTURE_WS? ~ ( hl_kws  ~ CAPTURE_WS? )* ~ eoi }
        hl_kws = _{ hl_infix | hl_reserved | hl_control | hl_value | hl_call | hl_sym | hl_str | hl_ops | hl_brackets | hl_num | hl_other }
        hl_control = { "if" | "else" | "for" | "while" | "repeat" | "return" }
        hl_reserved = { "function" }
        hl_value = { null | na | inf | boolean_true | boolean_false }
        hl_call = _{ hl_callname ~ CAPTURE_WS* ~ hl_open }
        hl_callname = { hl_sym | hl_str }
        hl_sym = { hl_symbol_backticked | symbol_ident }
            hl_symbol_backticked = ${ "`" ~ (!"`" ~ ANY)* ~ ( "`" | eoi ) }
        hl_str = ${ "\"" ~ string ~ ( "\"" | eoi ) | "'" ~ string ~ ( "'" | eoi ) }
        hl_num = { number ~ "L"? }
        hl_infix = { infix }
        hl_open = { "(" }
        hl_brackets = { hl_open | ")" | "[" | "]" | "{" | "}" }
        hl_ops = { "," | "+" | "-" | "*" | "/" | "<" | ">" | "=" | "&" | "!" | "^" | "?" }
        hl_other = { ANY }


// repl line feed parsing

    repl = _{ WS* ~ expr ~ WS* ~ eoi }

// expression basics

    expr = { block | block_inline | inline }
        block  = { "{" ~ WS* ~ block_inline* ~ WS* ~ inline? ~ WS* ~ "}" }

        // within an expression block, newlines are meaningful syntax
        block_inline = { inline ~ WS_NO_NL* ~ expr_end ~ WS* } 
        expr_end = _{ ";" | NEWLINE | eoi }
        paren_expr = _{ "(" ~ WS* ~ expr ~ WS* ~ ")" }
        atom_expr = _{ atom | paren_expr }
        inline = { atom_expr ~ ( WS* ~ infix ~ WS* ~ atom_expr )* }

        infix = _{ add | subtract | multiply | divide | assign }
            add = { "+" }
            subtract = { "-" }
            multiply = { "*" }
            divide = { "/" }
            assign = { "<-" }

        atom = _{ 
              kw_function
            | kw_break
            | kw_continue
            | kw_if_else
            | kw_for
            | kw_while
            | kw_repeat
            | call 
            | null
            | na
            | inf
            | boolean_true
            | boolean_false
            | integer_expr
            | number 
            | string_expr 
            | symbol 
            | block 
        }

// keyworded (kw) syntax

    kw_function = { "function" ~ WS* ~ list ~ WS* ~ expr }
    kw_if_else = { "if" ~ WS* ~ "(" ~ WS* ~ expr ~ WS* ~ ")" ~ WS* ~ expr ~ WS* ~ ("else" ~ WS* ~ expr)? }
    kw_for = { "for" ~ WS* ~ "(" ~ WS* ~ symbol ~ WS+ ~ "in" ~ WS+ ~ expr ~ WS* ~ ")" ~ WS* ~ expr }
    kw_while = { "while" ~ WS* ~ "(" ~ WS* ~ expr ~ WS* ~ ")" ~ WS* ~ expr }
    kw_repeat = { "repeat" ~ WS* ~ expr }
    kw_break = { "break" }
    kw_continue = { "continue" }

// reserved value types

    null = { "NULL" }
    na = { "NA" }
    inf = { "Inf" }
    boolean_true = { "TRUE" }
    boolean_false = { "FALSE" }

// atomic value types

    number = @{
        "-"?
        ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
        ~ ("." ~ ASCII_DIGIT*)?
    }

    integer_expr = _{ integer ~ "L" }
        integer = @{ "-"? ~ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }

    string_expr = ${ "\"" ~ string ~ "\"" | "'" ~ string ~ "'" }
        string = @{ char* }
        char = {
            !("\"" | "\\") ~ ANY
            | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
            | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
        }

// symbols & calls

    symbol = _{ symbol_backticked | symbol_ident }
        symbol_backticked = ${ "`" ~ (!"`" ~ ANY)* ~ "`" }
        symbol_ident = ${ ( ASCII_ALPHA | "." | "_" ) ~ ( ASCII_ALPHANUMERIC | "." | "_" )* }

    call = { symbol ~ WS* ~ list }
        list = { "(" ~ ((WS* ~ elem ~ WS* ~ ",")* ~ WS* ~ elem)? ~ WS* ~ ")" }
        ellipsis = { "..." }
        elem = _{ ellipsis | named | expr }
        named = { symbol ~ WS* ~ "=" ~ WS* ~ expr }